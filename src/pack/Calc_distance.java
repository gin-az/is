package pack;/*Пакет (package) — это некий контейнер, который используется для того, чтобы изолировать имена классов. 
pack - название пакета */

import java.awt.*;/*	java. - Все стандартные классы, поставляемые с системой Java, хранятся в пакете java.
java.awt  - подключение пакета awt, содержащего базовые графические функции:GridLayout, BorderLayout и т.д.
"*"-включение всех элементов библиотеки awt */	
import java.awt.event.*;/*Подключаем объект event, который содержит свойства, описывающие некое событие.
Каждый раз, когда происходит какое-либо событие, 
объект Event передается соответствующей программе обработки.
Используемым событием в нашей программе являются ACTION события.
*/
import javax.swing.*;// библиотека для графического интерфейса
import javax.swing.border.*;//библиотека необходимая для того, чтобы установить отступы

public class Calc_distance extends JDialog {/*Класс Calc_distance, который доступен для любого файла из пакета pack наследует 
	функции элемента JDialog */
	private static final long serialVersionUID = 1L;

	public static void main(String[] args) {/*  
		Модификатор доступа public означает, что метод main(String[] args)виден и доступен любому классу. 
		static позволяет определять статические методы. Это такие методы, которые являются общими для класса, а не для
		отдельного объекта этого класса. Также они могут работать лишь со статическими полями класса.К статическим методам 
		и переменным можно обращаться через имя класса.
		void означает, что метод main(String[] args)не возвращает данных в программу, которая его вызвала, 
		а просто выводит на экран строку.
		В методе main слова String[] args означают,что этот может получать массив объектов с типом String, т.е. текстовые данные.
		Программа может состоять из нескольких классов, но только один из них содержит метод main().
		Все существующие реализации Java-интерпретаторов, получив команду интерпретировать класс, 
		начинают свою работу с вызова метода main. 
		*/
		try {/* Для задания блока программного кода, который требуется защитить от исключений, используется ключевое слово try. 
			Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
			Исключение – это проблемная ситуация, возникающая по мере выполнения кода программы. Работает она так:
			1.Выполняется код внутри блока try. 2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение 
			доходит до конца try и потом прыгает через catch. 3.Если в нём возникнет ошибка, то выполнение try на ней
			 прерывается, и управление прыгает в начало блока catch(err).
			*/
			Calc_distance Calc_distance = new Calc_distance(); 
			Calc_distance.setDefaultCloseOperation(DISPOSE_ON_CLOSE); //при закрытии формы происходит выход из приложения
			Calc_distance.setVisible(true); //устанавливаем что окно видимое
			Calc.Calcul_distance(); //рассчитваем необходимые данные. Функция расположена в файле Calc
		} catch (Exception e) {
			/* Для задания блока программного кода, который требуется защитить от исключений, используется ключевое слово try. 
			Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
			Исключение – это проблемная ситуация, возникающая по мере выполнения кода программы. Работает она так:
			1.Выполняется код внутри блока try. 2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение 
			доходит до конца try и потом прыгает через catch. 3.Если в нём возникнет ошибка, то выполнение try на ней
			 прерывается, и управление прыгает в начало блока catch(err).
			*/
			e.printStackTrace();
		}
	}

	public static JLabel Label_100km, Label_n_km, Label_n_l, Label_price;//текстовые поля,доступные из любого файла пакета pack
	/*static позволяет определять статические методы. Это такие методы, которые являются общими для класса, а не для
отдельного объекта этого класса. Также они могут работать лишь со статическими полями класса.К статическим методам 
и переменным можно обращаться через имя класса.*/
	public Calc_distance() {//метод, описывающий какие поля и кнопки располагаются на JDialog

		setTitle("Расчет расхода топлива"); //устанавливаем заголовок окна
		setSize(430, 440); // указывает ширину и высоту.
		setLocationRelativeTo(null);//установить посередине экрана
		setResizable(false); //запрет на расширение окна 
		
		getContentPane().setLayout(new BorderLayout());// для данной панели устанавливается менеджер компоновки BorderLayout
		 /*	Оператор new создает экземпляр указанного класса
	  	Метод setLayout - Вызов менеджера компоновки, который задает определенный порядок панелей в контейнере.
 		Менеджер размещения BorderLayout - тип разбивки контейнера, при котором всё пространство контейнера разбивается 
 		на пять частей. В каждой из этих частей располагается один компонент. 
 		При добавлении компонента на контейнер с BorderLayout разработчик обязательно указывает, 
 		куда именно он хочет поместить компонент.*/
		
		JPanel Panel_button = new JPanel();/*  Создание новой компоненты панели  */
		getContentPane().add(Panel_button, BorderLayout.SOUTH); //Добавление на главную панель, вниз.
		
		Panel_button.setLayout(new GridLayout(1, 2, 10, 5));/*установка менеджера компоновки GridLayout.
		На панеле будет 1 строка,2столбца, расстояние между столбцами - 10 */
		
		JButton Button_delete = new JButton("Очистить результаты"); /*В скобках надпись на кнопке*/
		Panel_button.add(Button_delete);/*  Добавление кнопки в панель */
			
		JButton Button_exit = new JButton("Закрыть");
		Panel_button.add(Button_exit);
		
		JPanel Panel_text = new JPanel(); /*  Создание новой панели  */
		getContentPane().add(Panel_text, BorderLayout.CENTER);//Добавление на главную панель, в центр.

		Panel_text.setLayout(new FlowLayout(FlowLayout.LEFT, 7, 15)); 
		/*setLayout-Вызов менеджера компоновки, который задает определенный порядок панелей в Panel_text.
      	Менеджер размещения FlowLayout размещает компоненты подобно тому как текстовый редактор располагает слова. 
      	Компоненты располагаются друг за другом слева направо и сверху вниз, начиная с левого верхнего угла. 
      	Если строка заполнена и следующий компонент в ней не помещается, то он переносится на новую строку. 
      	Вокруг каждого компонента оставляется небольшое свободное пространство.
       	Оператор new создает экземпляр указанного класса 
       	7 - горизонтальный отступ, 15 - вертикальный */
		Panel_text.setBorder(new EmptyBorder(74,0,123,0)); //установка внутренних отступов(74 сверху,123 снизу)

        Font font = new Font(null, Font.BOLD, 13); //создание нового шрифта. Шрифт жирный, размер 13

		JLabel Label_1 = new JLabel("Средний расход топлива на 100 км составляет");
		Panel_text.add(Label_1);//добавить на панель, add - метод добавления компоненты в контейнер.
				
		Label_100km = new JLabel(""); //для отображения рассчитанного значения средний расход топлива
		Panel_text.add(Label_100km);//добавить на панель, add - метод добавления компоненты в контейнер.
		Label_100km.setFont(font); 
		Label_100km.setForeground(Color.BLUE);
		/*setFont - устанавливаем ля данного компонента шрифт font, 
		 setForeground -  цвет шрифта синий*/
		
		JLabel Label_2 = new JLabel("л.");
		Panel_text.add(Label_2);//добавить на панель, add - метод добавления компоненты в контейнер.
		
		JLabel Label_3 = new JLabel("Значит, для того, чтобы проехать");
		Panel_text.add(Label_3);//добавить на панель, add - метод добавления компоненты в контейнер.
				
		Label_n_km = new JLabel(""); //для отображения рассчитанного значения количество км
		Panel_text.add(Label_n_km);//добавить на панель, add - метод добавления компоненты в контейнер.
		Label_n_km.setFont(font);
		Label_n_km.setForeground(Color.BLUE);
		/*setFont - устанавливаем ля данного компонента шрифт font, 
		 setForeground -  цвет шрифта синий*/
		
		JLabel Label_4 = new JLabel("км");
		Panel_text.add(Label_4);//добавить на панель, add - метод добавления компоненты в контейнер.
		
		JLabel Label_5 = new JLabel("необходимо");
		Panel_text.add(Label_5);//добавить на панель, add - метод добавления компоненты в контейнер.		
		
		Label_n_l = new JLabel("");//для отображения рассчитанного значения количество литров топлива
		Panel_text.add(Label_n_l);//добавить на панель, add - метод добавления компоненты в контейнер.
		Label_n_l.setFont(font);
		Label_n_l.setForeground(Color.BLUE);
		/*setFont - устанавливаем ля данного компонента шрифт font, 
		 setForeground -  цвет шрифта синий*/
		
		JLabel Label_6 = new JLabel("л топлива.");
		Panel_text.add(Label_6);//добавить на панель, add - метод добавления компоненты в контейнер.
				
		JLabel Label_7 = new JLabel("Стоимость поездки составит");
		Panel_text.add(Label_7);//добавить на панель, add - метод добавления компоненты в контейнер.
				
		Label_price = new JLabel("");//для отображения рассчитанного значения стоимость поездки
		Panel_text.add(Label_price);//добавить на панель, add - метод добавления компоненты в контейнер.
		Label_price.setFont(font);
		Label_price.setForeground(Color.BLUE);
		/*setFont - устанавливаем ля данного компонента шрифт font, 
		 setForeground -  цвет шрифта синий*/
		
		JLabel Label_8 = new JLabel("руб.");
		Panel_text.add(Label_8);//добавить на панель, add - метод добавления компоненты в контейнер.
				
				
		Button_exit.addActionListener(new ActionListener() //добавляем слушателя события для кнопки 
				/*      "."  - указывает к какой переменной (кнопке) следует применить слушателя.
			 	addActionListener - добавление слушателя ActionListener к кнопке
			  	new - Оператор new создает экземпляр указанного класса 
			  	(Для того чтобы кнопки стали функциональными, каждой из них необходимо присвоить обработчик событий, 
			  	который будет отвечать за реагирование на события. 
			  	В нашем случае требуется идентифицировать событие нажатия кнопки – путем щелчка мышью. 
			  	Поэтому будет использоваться интерфейс "ActionListener", 
			  	предназначенный для обработки событий "ActionEvent".
			  	тело интерфейса указывается ниже после фигурной скобки "{"
	    	    */              
		   {                                                         
		    public void actionPerformed(ActionEvent e)      
		    /* 	ActionListener" имеет метод "actionPerformed" объекта "ActionEvent", 
	      	который реализуется путем простого вызова обработчика событий ActionPerformed.
	      	Ключевое слово public означает, что метод actionPerformed() доступен для любого другого класса Java
	      	Ключевое слово void означает, что метод main() не возвращает данных в программу, которая его вызвала. 
	      	*/  
		    {    // описываем что будет происходить при нажатии на кнопку Закрыть - программа завершит свою работу
	            System.exit(0);		    	
		    }                                                        
		   }); 
		

		
		Button_delete.addActionListener(new ActionListener()     
				//добавляем слушателя события для кнопки 
				/*      "."  - указывает к какой переменной (кнопке) следует применить слушателя.
			 	addActionListener - добавление слушателя ActionListener к кнопке
			  	new - Оператор new создает экземпляр указанного класса 
			  	(Для того чтобы кнопки стали функциональными, каждой из них необходимо присвоить обработчик событий, 
			  	который будет отвечать за реагирование на события. 
			  	В нашем случае требуется идентифицировать событие нажатия кнопки – путем щелчка мышью. 
			  	Поэтому будет использоваться интерфейс "ActionListener", 
			  	предназначенный для обработки событий "ActionEvent".
			  	тело интерфейса указывается ниже после фигурной скобки "{"
	    	    */   
		   {		
		    public void actionPerformed(ActionEvent e)  
		    /* 	ActionListener" имеет метод "actionPerformed" объекта "ActionEvent", 
	      	который реализуется путем простого вызова обработчика событий ActionPerformed.
	      	Ключевое слово public означает, что метод actionPerformed() доступен для любого другого класса Java
	      	Ключевое слово void означает, что метод main() не возвращает данных в программу, которая его вызвала. 
	      	*/  
		    {
		    	setVisible(false);//данное окно станет невидимым
		    	Index.Index.setVisible(true); /*устанавливаем что окно Расчет расхода топлива в котором пользователь 
		    	вводит данные видимое */
		    	
		    	//	Обнуляем все поля, переменные, флажки ставим в состояние выключен
		    	Distance.TextField_100km.setText("");
		    	Distance.TextField_distance.setText("");
		    	Distance.TextField_price.setText("");
		    	Distance.CheckBox_100km.setSelected(false);
		    	Distance.CB_100km=0;
		    			
		    	Distance100km.TextField_probeg_do.setText("");
		    	Distance100km.TextField_probeg_next.setText("");
		    	Distance100km.TextField_volume.setText("");
		    	Distance100km.TextField_fuel.setText("");
		    	Distance100km.TextField_pass_dist.setText("");
		    	Distance100km.CheckBox_how_1.setSelected(false);
		    	Distance100km.CheckBox_how_2.setSelected(false);
		    	Distance100km.CB_how_1=0;
		    	Distance100km.CB_how_2=0;

			    Index.JTP.setSelectedIndex(0);//устанавливаем что программа должна открыться на вкладке 0
		    }                                                        
		   }); 
	}
	
	
	
	
	
	}
	
	 	
	
